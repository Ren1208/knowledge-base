#бизнес_аналитика #реализация #динамическая_сегментация 

---
## Постановка задачи и исходные данные

Теперь рассмотрим, как можно задавать статусы (сегменты) клиентам торговой фирмы с помощью модуля динамической сегментации. Использование этого модуля даст возможность увидеть, например, как клиенты переходят из одного статуса в другой в зависимости от изменений в их расходах, а также общую сумму расходов клиентов, обладающих определённым статусом.

Допустим, у нас есть [[Исходные данные для динамической сегментации|исходные данные]] о количестве клиентов и их расходах некоторой коммерческой фирмы. Мы хотим каждому клиенту задать статус (сегмент), который соответствовал бы его затратам в разрезе по годам. Возьмём такое распределение: SILVER статус - затраты от 0 до 100; GOLD статус - от 100 до 500; PLATINUM статус - от 500 до 2000; DIAMOND статус - от 2000 и более. Для наглядности оформим в виде таблицы.

![[Реализация динамической сегментации.png]]

На выходе хотим получить два дашборда. Они должны показывать количество клиентов и общую сумму их расходов по выбранным сегментам соответственно.

---
## Разработка дашборда, отображающего количество клиентов по выбранным сегментам

Начнём с первого дашборда. Представим исходные данные о количестве клиентов за каждый год в разрезе по сегментам.

![[Реализация динамической сегментации-1.png]]

Теперь создадим меру, которая позволит выбирать только определённые сегменты и суммировать количество клиентов в этих сегментах по годам.

```sql
Seg. Customers :=
IF (HASONEVALUE ('Date'[Calendar Year]),
    VAR CustomersInSegment =              
        FILTER (
            ALLSELECTED (Customer),
            VAR SalesOfCustomer = [Sales Amount]
            VAR SegmentForCustomer =           
                FILTER (                       
                    'Customer segments',
                    NOT ISBLANK (SalesOfCustomer)
                        && 'Customer segments'[Min Sales] <  SalesOfCustomer
                        && 'Customer segments'[Max Sales] >= SalesOfCustomer
                )
            VAR IsCustomerInSegments = NOT ISEMPTY (SegmentForCustomer)
            RETURN IsCustomerInSegments
        )
    VAR Result =
        CALCULATE (
            COUNTROWS (Customer),           
            KEEPFILTERS (CustomersInSegment)
        )
    RETURN Result
)
```

Функция FILTER фильтрует таблицу «Customer» по условиям, связанным с выручкой клиентов и их принадлежностью к определенным сегментам из таблицы «Customer segments».

ALLSELECTED учитывает все выбранные значения в контексте фильтров. Здесь она используется для создания фильтра, который учитывает все выбранные значения, чтобы корректно определить клиентов, удовлетворяющих условиям сегментации.

KEEPFILTERS является модификатором контекста, который сохраняет фильтры, применённые к указанной таблице или столбцу. В данном случае он используется для сохранения фильтра, примененного к результатам функции FILTER, чтобы правильно подсчитать количество клиентов в каждом сегменте.

Размещаем меру на дашборд и получаем [[Дашборды модуля динамической сегментации|визуализацию]].

---
## Разработка дашборда, отображающего общую сумму расходов клиентов по выбранным сегментам

Переходим к реализации дашборда, который будет показывать общую сумму расходов клиентов. Для этого создадим следующую меру:

```sql
Sales Seg. Customers :=
SUMX (VALUES ('Date'[Calendar Year]),     
      VAR CustomersInSegment =              
        FILTER (ALLSELECTED (Customer),
                VAR SalesOfCustomer = [Sales Amount]
                VAR SegmentForCustomer =           
                FILTER ('Customer segments',
                    NOT ISBLANK (SalesOfCustomer)
                    && 'Customer segments'[Min Sales] < SalesOfCustomer
                    && 'Customer segments'[Max Sales] >= SalesOfCustomer
                )
            VAR IsCustomerInSegments = NOT ISEMPTY (SegmentForCustomer)
            RETURN IsCustomerInSegments
        )
    VAR Result =
        CALCULATE ([Sales Amount],                   
                   KEEPFILTERS (CustomersInSegment)
        )
    RETURN Result
)
```

Функция SUMX вычисляет сумму выражения для каждой строки в указанной таблице или выражении. Здесь она используется для повторного применения сегментации для каждого выбранного года.

Размещаем меру на дашборд и получаем [[Дашборды модуля динамической сегментации|визуализацию]].
